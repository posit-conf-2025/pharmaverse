# ARDs using {cards} 
 
<a href="https://insightsengineering.github.io/cards/"><img src="https://raw.githubusercontent.com/insightsengineering/cards/main/man/figures/logo.png" align="center" height="300" alt="cards website" /></a>

## {cards}: Introduction

-   Part of the Pharmaverse

-   Collaboration between Roche, GSK, Novartis, Eli Lilly, Pfizer

-   Contains a variety of utilities for making ARDs

-   Can be used within the ARS workflow and separately

-   36k downloads per month 🤯

## Data used in examples

ADSL from `pharmaverseadam`
```{r }
#| code-fold: true

adsl <- pharmaverseadam::adsl |> 
  dplyr::filter(SAFFL=="Y") |> 
  dplyr::mutate(ARM2 = ifelse(startsWith(ARM, "Xanomeline"), "Xanomeline", ARM))
```

ADAE from `pharmaverseadam`
```{r }
#| code-fold: true

adae <- pharmaverseadam::adae |> 
  dplyr::filter(SAFFL=="Y") |> 
  dplyr::mutate(ARM2 = ifelse(startsWith(ARM, "Xanomeline"), "Xanomeline", ARM)) |> 
  dplyr::filter(AESOC %in% unique(AESOC)[1:3]) |> 
  dplyr::group_by(AESOC) |> 
  dplyr::filter(AEDECOD %in% unique(AEDECOD)[1:3]) |> 
  dplyr::ungroup()
```

## {cards}: `ard_tabulate()`

::: {.small}
- includes `n`, `%`, `N` by default
- _Any unobserved levels of the variables will be present in the resulting ARD._
:::

```{r}
#| message: true
library(cards)

adsl |> 
  ard_tabulate(
    variables = AGEGR1
  ) 
```

## {cards}: `ard_tabulate()`

::: {.small}
- includes `n`, `%`, `N` by default
- _Any unobserved levels of the variables will be present in the resulting ARD._
:::

```{r}
#| message: true
adsl |> 
  ard_tabulate(
    by = ARM2,
    variables = AGEGR1
  ) 
```


## {cards}: `ard_summary()`

```{r}
#| message: true
#| 
# create ARD with default summary statistics
adsl |> 
  ard_summary(
    variables = AGE
  )
```


## {cards}: `ard_summary()` by variable

::: {.small}
`by`: summary statistics are calculated by all combinations of the by variables, including unobserved factor levels
:::

```{r}
#| message: true
adsl |> 
  ard_summary(
    variables = AGE,
    by = ARM2         # stats by treatment arm
  ) 
```

## {cards}: `ard_summary()` statistics

::: {.small}
`statistic`: specify univariate summary statistics. Accepts _any_ function, base R, from a package, or user-defined.
:::


```{r}
#| message: true
cv <- function(x)  sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE)

adsl |> 
  ard_summary(  
    variables = AGE,
    by = ARM2,
    statistic = ~ list(cv = cv) # customize statistics
  )

```

## {cards}: `ard_summary()` statistics

::: {.small}
Customize the statistics returned for each variable
:::

```{r}
#| message: true
adsl |> 
  dplyr::mutate(AGE2 = AGE) |> 
  ard_summary(
    variables = c(AGE, AGE2),
    by = ARM2,
    statistic = list(AGE = list(cv = cv),
                     AGE2 = continuous_summary_fns(c("mean","median")))
  )
```

## {cards}: `ard_summary()` fmt_fun

::: {.small}
- Override the default formatting functions
- Can also update later via `update_ard_fmt_fun()`
:::
 
```{r}
#| message: true
adsl |> 
  ard_summary(
    variables = AGE,
    by = ARM2,                               
    fmt_fun = ~list(mean = 0)                
  ) |> 
  apply_fmt_fun() # add a character column of rounded results
```

## {cards}: Other Summary Functions 

- `ard_tabulate_value()`: similar to `ard_tabulate()`, but for dichotomous tabulations

- `ard_hierarchical()`: similar to `ard_tabulate()`, but built for nested tabulations, e.g. AE terms within SOC

- `ard_mvsummary()`: similar to `ard_summary()`, for multivariate summaries. The function accepts other arguments like the full and subsetted (within the by groups) data sets.

- `ard_missing()`: tabulates rates of missingness

The results from all these functions are entirely compatible with one another, and can be stacked into a single data frame. 🥞

## {cards}: Other Functions

In addition to exporting functions to prepare summaries, {cards} exports many utilities for wrangling ARDs and creating new ARDs. 

Constructing: `bind_ard()`, `tidy_as_ard()`, `nest_for_ard()`, `check_ard_structure()`, and many more

Wrangling: `get_ard_statistics()`, `replace_null_statistic()`, etc.


## {cards}: Stacking utilities

::: {.small}
- `data` and `.by` are shared by all `ard_*` calls

- Additional Options `.overall`, `.missing`, `.attributes`, and `.total_n` provide even more results

- By default, summaries of the `.by` variable are included
:::

```{r}
#| message: true
adsl |> 
  ard_stack( 
    .by = ARM2,      
    ard_summary(variables = AGE, statistic = ~ continuous_summary_fns(c("mean","sd"))), 
    ard_tabulate(variables = AGEGR1, statistic = ~ "p")
  )  
```

## Quick recap!

::: {.small}
- Let's compute summaries for a demography table that includes age (AGE), age group (AGEGR1), and sex (SEX) by treatment (ARM2)
- First, we compute the continuous summaries for AGE by ARM2
:::


```{r}
#| eval: false
ard_summary(
  data = adsl,
  by = ,
  variables = 
)
```


## Quick recap!

::: {.small}
- Let's compute summaries for a demography table that includes age (AGE), age group (AGEGR1), and sex (SEX) by treatment (ARM2)
- First, we compute the continuous summaries for AGE by ARM2
:::

```{r}
#| message: true
#| code-line-numbers: "3,4"
ard_summary(
  data = adsl,
  by = ARM2,
  variables = AGE 
)
```
 
## Quick recap!

::: {.small}
- Let's compute summaries for a demography table that includes age (AGE), age group (AGEGR1), and sex (SEX) by treatment (ARM2)
- Next, we compute the categorical summaries for AGEGR1 and SEX by ARM2
::: 

```{r}
#| eval: false
ard_tabulate(
  data = adsl,
  by = ,
  variables = 
)
```


## Quick recap!

::: {.small}
- Let's compute summaries for a demography table that includes age (AGE), age group (AGEGR1), and sex (SEX) by treatment (ARM2)
- Next, we compute the categorical summaries for AGEGR1 and SEX by ARM2
::: 
```{r}
#| message: true
#| code-line-numbers: "3,4"
ard_tabulate(
  data = adsl,
  by = ARM2,
  variables = c(AGEGR1, SEX) 
)
```



## Quick recap!

::: {.small}
Let's compute summaries for a demography table that includes age (AGE), age group (AGEGR1), and sex (SEX) by treatment (ARM2) in a *single `ard_stack()` call, including:

  - summaries by ARM2 as performed above
  
  - continuous summaries from part A for AGE
  
  - categorical summaries from part B for AGEGR1 and SEX
:::

```{r}
#| eval: false
ard_stack(
  data = adsl,
  .by = ARM2,
  
  # add ard_* calls here
  
)
```


## Quick recap!

::: {.small}
Let's compute summaries for a demography table that includes age (AGE), age group (AGEGR1), and sex (SEX) by treatment (ARM2) in a *single `ard_stack()` call, including:

  - summaries by ARM2 as performed above
  
  - continuous summaries from part A for AGE
  
  - categorical summaries from part B for AGEGR1 and SEX
:::

```{r}
#| message: true
#| code-line-numbers: "4,5"
ard_stack(
  data = adsl,
  .by = ARM2,
  ard_summary(variables = AGE),
  ard_tabulate(variables = c(AGEGR1, SEX))
)
```

## Quick recap!

::: {.small}
We can also add:

- Overall summaries for all variables
- Total N
:::

```{r}
#| message: true
#| code-line-numbers: "6,7"
ard_stack(
  data = adsl,
  .by = ARM2,
  ard_summary(variables = AGE),
  ard_tabulate(variables = c(AGEGR1, SEX)),
  .overall = TRUE,
  .total_n = TRUE
)
```


## {cards}: Hierarchical Summary Functions

Following hierarchical summary functions aid in nested tabulations (e.g. AE terms within SOC):

-   `ard_hierarchical()`: calculating nested subject-level rates

-   `ard_hierarchical_count()`: calculating nested event-level counts
  

## {cards}: `ard_hierarchical` 

::: {.small}

This function specializes in calculating **subject**-level rates.

- Rates computed on lowest level `variables`, nested within others

- `id` helps to check that no duplicate rows exist within the `c(id, variables)` columns

- `denominator` dictates the denominator for the rates

:::

```{r} 
#| message: true
adae |> 
  dplyr::slice_tail(n = 1L, by = c(USUBJID, ARM, AESOC, AEDECOD)) |> 
  ard_hierarchical(
    variables = c(AESOC, AEDECOD),
    by = TRT01A,
    id = USUBJID,
    denominator = adsl
  )
```

## {cards}: `ard_hierarchical_count` 

::: {.small}

This function specializes in calculating **event**-level frequencies.

:::

```{r}
#| message: true
adae |> 
  ard_hierarchical_count( 
    variables = c(AESOC, AEDECOD),
    by = TRT01A
  )
```

## Hierarchical summaries many ways

- Displays for hierarchical data typically report on each level of the hierarchy (Any AE Overall, by System Organ Class, by Preferred Term)

- This can mean several calls to the `ard_hierarchical_*` functions 

- Further, subject-level summaries require a different subset of the data each time. For example, to calculate Overall rates, we need to subset to 1 record per subject in ADAE. 

::: {.fragment}
- Is there an easier way?
:::

## {cards}: Stacking function for `ard_hierarchical()`

::: {.small}

- `ard_hierarchical` stacking functions simplify this multi-step process into a single step

- The `id` argument is used to subset the data along the way

:::

```{r}
#| eval: FALSE
adae |> 
  ard_stack_hierarchical(
    variables = c(AESOC, AEDECOD),
    by = TRT01A,
    id = USUBJID,
    denominator = pharmaverseadam::adsl
  )
```

```{r}
#| echo: FALSE
ard_hier <- ard_stack_hierarchical(
  data = adae,
  variables = c(AESOC, AEDECOD),
  by = TRT01A,
  id = USUBJID,
  denominator = pharmaverseadam::adsl
)

ard_hier |> 
  dplyr::filter(
    dplyr::if_any(c(group2_level, variable_level), ~ .x %in% "GASTROINTESTINAL DISORDERS"), 
    group1_level %in% "Placebo"
    )

```

## {cards}: Stacking function for `ard_hierarchical_count()`

::: {.small}

- Below is the stacking function for event-level summaries, aligned with `ard_hierarchical_count()`

:::

```{r}
#| eval: FALSE
adae |> 
  ard_stack_hierarchical_count(
    variables = c(AESOC, AEDECOD),
    by = TRT01A, 
    denominator = pharmaverseadam::adsl
  )
```

```{r}
#| echo: FALSE
ard_hier_c <- ard_stack_hierarchical_count(
  data = adae,
  variables = c(AESOC, AEDECOD),
  by = TRT01A, 
  denominator = pharmaverseadam::adsl
)

ard_hier_c |> 
  dplyr::filter(
    dplyr::if_any(c(group2_level, variable_level), ~ .x %in% "GASTROINTESTINAL DISORDERS"), 
    group1_level %in% "Placebo"
    )
```


## Exercise 🏃‍➡️

1. Navigate to Posit Cloud script `exercises/04-ARD.R` 

2. Compute the nested AE tabulations as described.

3. Add the "completed" sticky note to your laptop when complete.


```{r}
#| echo: false
#| cache: false
library(countdown)
countdown(minutes = 10, play_sound = TRUE)
```


## {cardx}

-   Extension of the {cards} package, providing additional functions to create Analysis Results Datasets (ARDs)

-   The {cardx} package exports many `ard_*()` function for statistical methods.

![](images/cards-cardx-hex.png){fig-alt="cards and cardx package logos" fig-align="center"}

## {cardx}

-   Exports ARD frameworks for statistical analyses from many packages 

::: {.larger}

      - {stats}
      - {car}
      - {effectsize}
      - {emmeans}
      - {geepack}
      - {lme4}
      - {parameters}
      - {smd}
      - {survey}
      - {survival}

:::

-   This list is growing (rather quickly) 🌱

## {cardx} t-test Example

::: {.small}

- We see the results like the mean difference, the confidence interval, and p-value as expected.

- And we also see the function's inputs, which is incredibly useful for re-use, e.g. we know that we did not use equal variances.

:::

```{r}
#| message: true
adsl |> 
  cardx::ard_stats_t_test(by = ARM2, variables = AGE)
```

## {cardx} t-test Example

::: {.small}

- _What to do if a method you need is not implemented?_

- It's simple to wrap existing frameworks to customize.

- One-sample t-test example utilizing `cards::ard_summary()`.

:::

```{r}
#| message: true
adsl |> 
  cards::ard_summary(
    variables = AGE,
    statistic = everything() ~ list(t_test = \(x) t.test(x) |> broom::tidy())
  ) |> 
  dplyr::mutate(context = "t_test_one_sample")
```

## {cardx} t-test Example

::: {.small}

- How to modify if we need a two-sample test, or more generally accessing other columns in the data frame.

:::

```{r}
#| message: true
adsl |> 
  cards::ard_mvsummary(
    variables = AGE,
    statistic = 
      ~ list(t_test = \(x, data, ...) t.test(x ~ data$ARM2) |> broom::tidy())
  ) |> 
  dplyr::mutate(group1 = "ARM2", context = "t_test_two_sample") |> 
  cards::tidy_ard_column_order()
```

## {cardx} Regression

-   Includes functionality to summarize nearly every type of regression model in the R ecosystem: 

::: {.small}

`r broom.helpers::supported_models$model` (and more)

:::


## {cardx} Regression

::: {.small}

The `cardx::ard_regression()` does **a lot** for us in the background.

- Identifies the variable from the regression terms (i.e. groups levels of the same variable)
- Identifies reference groups from categorical covariates
- Finds variable labels from the source data frames
- Knows the total N of the model, the number of events, and can do the same for each level of categorical variables
- Contextually aware of slopes, odds ratios, hazard ratios, and incidence rate ratios
- And much _**much**_ more.

:::

```{r}
lm(AGE ~ ARM2, data = adsl) |>
  cardx::ard_regression(add_estimate_to_reference_rows = TRUE)
```


## When things go wrong 😱

::: {.small}

What happens when statistics are un-calculable? 

:::
```{r}
#| message: true
ard_gone_wrong <- 
  adsl |> 
  ard_summary(
    by = ARM2,
    variable = AGEGR1,
    statistic = ~list(kurtosis = \(x) e1071::kurtosis(x))
  ) |> 
  cards::replace_null_statistic()
ard_gone_wrong
```

::: {.fragment}

```r
cards::print_ard_conditions(ard_gone_wrong)
```

![](images/ard-error-msg.png)

:::

::: {.notes}

- Where is the statistic? `AGEGR1` is _character_

- Even when there are errors or warnings, we still get the ARD with the expected structure returned.

  - THIS IS BIG! There are MANY circumstances, when you are designing TLGs early in a study when you do not have all the data required to calculate every statistic.
  
  - This allows you to design everything up-front.
  
- We can also report these warnings and errors back to users. <!CLICK!>

:::
